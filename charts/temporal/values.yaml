nameOverride: ""
fullnameOverride: ""
# Chart debug mode
# (eg. disable helm hook delete policy)
debug: false
imagePullSecrets: []
# Custom Service account management
serviceAccount:
  # Whether to create service account or not
  create: false
  # Name of the service account.
  # Uses `name` if set.
  # If `create: true` defaults to temporal.fullname, otherwise uses the namespace's default serviceAccount.
  name:
  # extraAnnotations would let users add additional annotations
  extraAnnotations:
additionalAnnotations: {}
additionalLabels: {}
server:
  enabled: true
  image:
    repository: temporalio/server
    tag: 1.29.1
    pullPolicy: IfNotPresent
  # Global default settings (can be overridden per service)
  replicaCount: 1
  readinessProbe: {}
  metrics:
    # Annotate pods and services directly with the following Prometheus annotations.
    # prometheus.io/job
    # prometheus.io/port
    # prometheus.io/scheme
    # prometheus.io/scrape
    annotations:
      enabled: true
    # Additional tags to be added to Prometheus metrics
    tags: {}
    # Tags to be excluded in Prometheus metrics
    excludeTags: {}
    prefix:
    # Enable Prometheus ServiceMonitor
    # Use this if you installed the Prometheus Operator (https://github.com/coreos/prometheus-operator).
    serviceMonitor:
      enabled: false
      interval: 30s
      # Set additional lables to all the ServiceMonitor resources
      additionalLabels: {}
      #  label1: value1
      #  label2: value2
      # Set Prometheus metric_relabel_configs via ServiceMonitor
      # Use metricRelabelings to adjust metric and label names as needed
      metricRelabelings: []
      # - action: replace
      #   sourceLabels:
      #   - exported_namespace
      #   targetLabel: temporal_namespace
      # - action: replace
      #   regex: service_errors_(.+)
      #   replacement: ${1}
      #   sourceLabels:
      #   - __name__
      #   targetLabel: temporal_error_kind
      # - action: replace
      #   regex: service_errors_.+
      #   replacement: temporal_service_errors
      #   sourceLabels:
      #   - __name__
      #   targetLabel: __name__
    prometheus:
      timerType: histogram
  deploymentLabels: {}
  deploymentAnnotations: {}
  deploymentStrategy: {}
  podAnnotations: {}
  podLabels: {}
  secretLabels: {}
  secretAnnotations: {}
  resources: {}
  # We usually recommend not to specify default resources and to leave this as a conscious
  # choice for the user. This also increases chances charts run on environments with little
  # resources, such as Minikube. If you do want to specify resources, uncomment the following
  # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
  # limits:
  #  cpu: 100m
  #  memory: 128Mi
  # requests:
  #  cpu: 100m
  #  memory: 128Mi
  nodeSelector: {}
  tolerations: []
  affinity: {}
  minReadySeconds: 0
  additionalVolumes: []
  additionalVolumeMounts: []
  additionalEnv: []
  # for sidecar containers, add containers here with restartPolicy: Always
  additionalInitContainers: []
  securityContext:
    fsGroup: 1000
    runAsUser: 1000
  config:
    logLevel: "debug,info"
    # Define your TLS configuration here. See https://docs.temporal.io/references/configuration#tls
    # for configuration options. You must also use `server.additionalVolumeMounts` and `server.additionalVolumes`
    # to mount certificates (from Secret or ConfigMap etc) to the path you use below.
    # tls:
    #   internode:
    #     server:
    #       certFile: /path/to/internode/cert/file
    #       keyFile: /path/to/internode/key/file
    #       requireClientAuth: true
    #       clientCaFiles:
    #         - /path/to/internode/serverCa
    #     client:
    #       serverName: dnsSanInInternodeCertificate
    #       rootCaFiles:
    #         - /path/to/internode/serverCa
    #   frontend:
    #     server:
    #       certFile: /path/to/frontend/cert/file
    #       keyFile: /path/to/frontend/key/file
    #       requireClientAuth: true
    #       clientCaFiles:
    #         - /path/to/internode/serverCa
    #         - /path/to/sdkClientPool1/ca
    #         - /path/to/sdkClientPool2/ca
    #     client:
    #       serverName: dnsSanInFrontendCertificate
    #       rootCaFiles:
    #         - /path/to/frontend/serverCa
    # Define your Authorizer and ClaimMapper configuration here. See https://docs.temporal.io/self-hosted-guide/security#authorization
    # authorization:
    #   jwtKeyProvider:
    #     keySourceURIs:
    #       - http://localhost:/jwks.json
    #     refreshInterval: 1m
    #   permissionsClaimName: permissions
    #   authorizer: default
    #   claimMapper: default
    persistence:
      defaultStore: default
      visibilityStore: visibility
      # Important: numHistoryShards cannot be changed after the initial deployment.
      numHistoryShards: 512
      # Persistence configuration follows the raw Temporal server config format.
      # Driver is determined by which top-level key is present (cassandra vs sql).
      # For SQL stores, you can use either connectAddr: "host:port" or separate host/port fields.
      # Helm-specific fields (existingSecret, secretKey) are stripped before rendering to server config.
      datastores:
        default:
        # Example SQL configuration:
        # sql:
        #   pluginName: mysql8  # or postgres12, postgres12_pgx
        #   driverName: mysql8
        #   databaseName: temporal
        #   connectAddr: "mysql.example.com:3306"  # preferred format
        #   # OR use separate host/port:
        #   # host: mysql.example.com
        #   # port: 3306
        #   # connectProtocol defaults to "tcp" if not specified
        #   user: temporal_user
        #   password: ""  # optional, use existingSecret instead
        #   existingSecret: temporal-db-secret  # Helm-specific, stripped before rendering
        #   secretKey: password  # Helm-specific, default: password
        #   maxConns: 20
        #   maxIdleConns: 20
        #   maxConnLifetime: "1h"
        #   connectAttributes:
        #     tx_isolation: "READ-COMMITTED"
        #   tls:
        #     enabled: true
        #     caFile: /path/to/ca.pem
        # Example Cassandra configuration:
        # cassandra:
        #   hosts: "host1,host2"  # or ["host1", "host2"]
        #   port: 9042
        #   keyspace: temporal
        #   user: cassandra_user
        #   password: ""  # optional, use existingSecret instead
        #   existingSecret: temporal-cassandra-secret
        #   secretKey: password
        #   replicationFactor: 3
        #   consistency:
        #     default:
        #       consistency: "local_quorum"
        #       serialConsistency: "local_serial"
        visibility:
        # Example SQL configuration (same structure as default.sql):
        # sql:
        #   pluginName: mysql8
        #   driverName: mysql8
        #   databaseName: temporal_visibility
        #   connectAddr: "mysql.example.com:3306"
        #   # connectProtocol defaults to "tcp" if not specified
        #   user: temporal_user
        #   existingSecret: temporal-db-secret
        #   secretKey: password
        # Example Elasticsearch configuration:
        # elasticsearch:
        #   version: v7
        #   url:
        #     scheme: http
        #     host: "elasticsearch:9200"
        #   username: ""
        #   password: ""
        #   existingSecret: temporal-es-secret
        #   secretKey: password
        #   logLevel: error
        #   indices:
        #     visibility: temporal_visibility_v1
        # Additional stores can be added here and will pass through directly
        # archive:
        #   sql:
        #     pluginName: postgres12
        #     ...
    namespaces:
      # Enable this to create namespaces
      create: false
      namespace:
        - name: default
          retention: 3d
  frontend:
    service:
      # Evaluated as template
      annotations: {}
      type: ClusterIP
      port: 7233
      appProtocol: tcp
      membershipPort: 6933
      membershipAppProtocol: tcp
      httpPort: 7243
      httpAppProtocol: http
    readinessProbe:
      grpc:
        port: 7233
        service: temporal.api.workflowservice.v1.WorkflowService
    ingress:
      enabled: false
      # className:
      annotations: {}
      # kubernetes.io/ingress.class: traefik
      # ingress.kubernetes.io/ssl-redirect: "false"
      # traefik.frontend.rule.type: PathPrefix
      hosts:
        - "/"
        # - "domain.com/xyz"
        # - "domain.com"
      tls: []
      #  - secretName: chart-example-tls
      #    hosts:
      #      - chart-example.local
    metrics:
      annotations:
        enabled: true
      serviceMonitor: {}
      # enabled: false
      prometheus: {}
      # timerType: histogram
    deploymentLabels: {}
    deploymentAnnotations: {}
    deploymentStrategy: {}
    podAnnotations: {}
    podLabels: {}
    resources: {}
    nodeSelector: {}
    tolerations: []
    affinity: {}
    additionalEnv: []
    containerSecurityContext: {}
    topologySpreadConstraints: []
    podDisruptionBudget: {}
  internalFrontend:
    # Enable this to create internal-frontend
    enabled: false
    service:
      # Evaluated as template
      annotations: {}
      type: ClusterIP
      port: 7236
      appProtocol: tcp
      membershipPort: 6936
      membershipAppProtocol: tcp
      httpPort: 7246
      httpAppProtocol: http
    readinessProbe:
      grpc:
        port: 7236
        service: temporal.api.workflowservice.v1.WorkflowService
    metrics:
      annotations:
        enabled: true
      serviceMonitor: {}
      # enabled: false
      prometheus: {}
      # timerType: histogram
    deploymentLabels: {}
    deploymentAnnotations: {}
    deploymentStrategy: {}
    podAnnotations: {}
    podLabels: {}
    resources: {}
    nodeSelector: {}
    tolerations: []
    affinity: {}
    additionalEnv: []
    containerSecurityContext: {}
    topologySpreadConstraints: []
    podDisruptionBudget: {}
  history:
    service:
      # type: ClusterIP
      port: 7234
      appProtocol: tcp
      membershipPort: 6934
      membershipAppProtocol: tcp
    readinessProbe: {}
    metrics:
      annotations:
        enabled: true
      serviceMonitor: {}
      # enabled: false
      prometheus: {}
      # timerType: histogram
    deploymentLabels: {}
    deploymentAnnotations: {}
    deploymentStrategy: {}
    podAnnotations: {}
    podLabels: {}
    resources: {}
    nodeSelector: {}
    tolerations: []
    affinity: {}
    additionalEnv: []
    additionalEnvSecretName: ""
    containerSecurityContext: {}
    topologySpreadConstraints: []
    podDisruptionBudget: {}
  matching:
    service:
      # type: ClusterIP
      port: 7235
      appProtocol: tcp
      membershipPort: 6935
      membershipAppProtocol: tcp
    readinessProbe: {}
    metrics:
      annotations:
        enabled: false
      serviceMonitor: {}
      # enabled: false
      prometheus: {}
      # timerType: histogram
    deploymentLabels: {}
    deploymentAnnotations: {}
    deploymentStrategy: {}
    podAnnotations: {}
    podLabels: {}
    resources: {}
    nodeSelector: {}
    tolerations: []
    affinity: {}
    additionalEnv: []
    containerSecurityContext: {}
    topologySpreadConstraints: []
    podDisruptionBudget: {}
  worker:
    service:
      # type: ClusterIP
      port: 7239
      appProtocol: tcp
      membershipPort: 6939
      membershipAppProtocol: tcp
    readinessProbe: {}
    metrics:
      annotations:
        enabled: true
      serviceMonitor: {}
      # enabled: false
      prometheus: {}
      # timerType: histogram
    deploymentLabels: {}
    deploymentAnnotations: {}
    deploymentStrategy: {}
    podAnnotations: {}
    podLabels: {}
    resources: {}
    nodeSelector: {}
    tolerations: []
    affinity: {}
    additionalEnv: []
    containerSecurityContext: {}
    topologySpreadConstraints: []
    podDisruptionBudget: {}
admintools:
  enabled: true
  image:
    repository: temporalio/admin-tools
    tag: "1.29.1-tctl-1.18.4-cli-1.5.0"
    pullPolicy: IfNotPresent
  service:
    type: ClusterIP
    port: 22
    annotations: {}
  deploymentLabels: {}
  deploymentAnnotations: {}
  deploymentStrategy: {}
  podLabels: {}
  podAnnotations: {}
  nodeSelector: {}
  tolerations: []
  affinity: {}
  additionalVolumes: []
  additionalVolumeMounts: []
  additionalEnv: []
  additionalEnvSecretName: ""
  # for sidecar containers, add containers here with restartPolicy: Always
  additionalInitContainers: []
  resources: {}
  containerSecurityContext: {}
  securityContext: {}
  minReadySeconds: 0
  podDisruptionBudget: {}
web:
  # additionalInitContainers: []
  enabled: true
  replicaCount: 1
  image:
    repository: temporalio/ui
    tag: 2.42.1
    pullPolicy: IfNotPresent
  service:
    # set type to NodePort if access to web needs access from outside the cluster
    # for more info see https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
    type: ClusterIP
    # The below clusterIP setting can be set to "None" to make the temporal-web service headless.
    # Note that this requires the web.service.type to be the default ClusterIP value.
    # clusterIP:
    port: 8080
    appProtocol: http
    annotations: {}
    # loadBalancerIP:
  readinessProbe:
    initialDelaySeconds: 10
    httpGet:
      path: /healthz
      port: http
  ingress:
    enabled: false
    # className:
    annotations: {}
    # kubernetes.io/ingress.class: traefik
    # ingress.kubernetes.io/ssl-redirect: "false"
    # traefik.frontend.rule.type: PathPrefix
    hosts:
      - "/"
      # - "domain.com/xyz"
      # - "domain.com"
    tls: []
    #  - secretName: chart-example-tls
    #    hosts:
    #      - chart-example.local
  deploymentLabels: {}
  deploymentAnnotations: {}
  deploymentStrategy: {}
  podAnnotations: {}
  podLabels: {}
  resources: {}
  # We usually recommend not to specify default resources and to leave this as a conscious
  # choice for the user. This also increases chances charts run on environments with little
  # resources, such as Minikube. If you do want to specify resources, uncomment the following
  # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
  # limits:
  #  cpu: 100m
  #  memory: 128Mi
  # requests:
  #  cpu: 100m
  #  memory: 128Mi
  nodeSelector: {}
  tolerations: []
  affinity: {}
  additionalVolumes: []
  additionalVolumeMounts: []
  # Adjust Web UI config with environment variables:
  # https://docs.temporal.io/references/web-ui-environment-variables
  additionalEnv: []
  additionalEnvSecretName: ""
  containerSecurityContext: {}
  securityContext: {}
  topologySpreadConstraints: []
  minReadySeconds: 0
  podDisruptionBudget: {}
  useInternalFrontend: false
schema:
  backoffLimit: 100
  jobAnnotations: {}
  podAnnotations: {}
  podLabels: {}
  resources: {}
  containerSecurityContext: {}
  securityContext: {}

test:
  podAnnotations: {}
